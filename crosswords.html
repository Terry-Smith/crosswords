<!DOCTYPE html>
<html>
	<head>
		<meta name="viewport" content="width=device-width">
		<script>
			window.addEventListener("load", function(e) {
				displayPuzzle(testPuzzleDefinition, createPuzzleGrid(testPuzzleDefinition));
			});

			function moveCell(test, increment) {
				let focusEl = document.querySelector("[class~='puzzle-cell-focus']");
				if (focusEl !== undefined && focusEl !== null) {
					let cellindex = parseInt(focusEl.getAttribute("cellindex"));
					let i = cellindex;
					while (test(i)) {
						if (testPuzzleDefinition.cells[i] === "#") {
							break;
						}
						i = increment(i);
						if  (testPuzzleDefinition.cells[i] !== "#") {
							break;
						}
					}
					if (i != cellindex) {
						cellEl = document.querySelector(`[cellindex="${i}"]`);
						if (cellEl !== undefined && cellEl !== null) {
							cellEl.focus();
						}
					}
				}
			}
			
			function moveRight() {
				moveCell((i) => (i % testPuzzleDefinition.size < testPuzzleDefinition.size -1), (i) => (i + 1));
			}
			
			function moveLeft() {
				moveCell((i) => (i % testPuzzleDefinition.size > 0), (i) => (i - 1));
			}
			
			function moveUp() {
				moveCell((i) => (i > 0), (i) => (i - testPuzzleDefinition.size));
			}
			
			function moveDown() {
				moveCell((i) => (Math.floor(i / testPuzzleDefinition.size) < testPuzzleDefinition.size), (i) => (i + testPuzzleDefinition.size));
			}
			
			function moveNextCell() {
				if (testPuzzleState.direction === "a") {
					moveRight();
				} else {
					moveDown();
				}
			}

			function movePreviousCell() {
				if (testPuzzleState.direction === "a") {
					moveLeft();
				} else {
					moveUp();
				}
			}
			
			document.addEventListener("keydown", function(e) {
				let focusEl = document.querySelector("[class~='puzzle-cell-focus']");
				if (focusEl !== undefined && focusEl !== null) {
					let doDefault = true;
					if (/^[a-z]$/i.test(e.key)) {
						focusEl.innerText = e.key.toUpperCase();
						moveNextCell();
					} else if (e.key === " ") {
						testPuzzleState.toggleDirection();
						updateCurrentClue(testPuzzleDefinition, testPuzzleState);
					} else if (e.keyCode === 8) {
						focusEl.innerText = "";
						movePreviousCell();
					} else if (e.keyCode === 40) { // down
						moveDown();
						doDefault = false;
					} else if (e.keyCode === 38) { // up
						moveUp();
						doDefault = false;
					} else if (e.keyCode === 37) { // left
						moveLeft();
						doDefault = false;
					} else if (e.keyCode === 39) { // right
						moveRight();
						doDefault = false;
					}
					
					if (!doDefault) {
						e.preventDefault();
						e.cancelBubble = true;
						e.stopPropagation();
					}
				}
			});
			
			function isCell(el, puzzleDefinition) {
				if (el !== undefined && el !== null && el.classList.contains("puzzle-cell")) {
					let cellindex = parseInt(el.getAttribute("cellindex"));
					if (puzzleDefinition.cells[cellindex] !== "#") {
						return true;
					}
				}
				return false;
			}
			
			function isKey(el) {
				if (el.classList.contains("puzzle-keyboard-key")) {
					return true;
				}
				return false;
			}
			
//var tempEl = document.createElement("div");
//tempEl.innerHTML = '<input type="text" name="letterEnter" autocomplete="off" inputmode="text" class="puzzle-input"/>';
//var inputEl = tempEl.firstChild;
//document.lastChild.appendChild(inputEl);
			document.addEventListener("focusin", function(e) {
				if (isCell(e.target, testPuzzleDefinition)) {
					let focusEl = document.querySelector("[class~='puzzle-cell-focus']");
					if (focusEl !== undefined && focusEl !== null) {
						focusEl.classList.remove("puzzle-cell-focus");
					}
					e.target.classList.add("puzzle-cell-focus");
					testPuzzleState.focusInCellEl = e.target;
					testPuzzleState.currentCellEl = e.target;
					updateCurrentClue(testPuzzleDefinition, testPuzzleState);
				}
			});
			
			document.addEventListener("click", function(e) {
				if (isCell(e.target, testPuzzleDefinition)) {
					if (testPuzzleState.focusInCellEl === e.target) {
						testPuzzleState.focusInCellEl = undefined;
						return;
					}
					if (testPuzzleState.currentCellEl === e.target) {
						testPuzzleState.toggleDirection();
						updateCurrentClue(testPuzzleDefinition, testPuzzleState);
					} else {
						e.target.focus();
					}
				} else if (isKey(e.target)) {
					let focusEl = document.querySelector("[class~='puzzle-cell-focus']");
					if (focusEl !== undefined && focusEl !== null) {
						let key = e.target.innerText;
						if (key === "_") {
							testPuzzleState.toggleDirection();
							updateCurrentClue(testPuzzleDefinition, testPuzzleState);
						} else if (key === "bs") {
							focusEl.innerText = "";
							movePreviousCell();
						} else if (/^[a-z]$/i.test(key)) {
							focusEl.innerText = key.toUpperCase();
							moveNextCell();
						}
					}
				}
			});

			testPuzzleCellContent = "SUSHI#SAPS#OPALASHEN#PLIE#VERYWEIRDPRESCIENCEURIS#AIR#SLR###PIT#PINON#LAPEL#DECENT#CBSNEWS###HEF#AAA#DRED#THEPREFABFOUR#ASEA#ELL#YOU###SAMPLES#ABATED#PRILE#EPSOM#XED###ANT#USO#SCARVICTORPREMATUREERIE#EDEN#OASISTAGS#STET#KNEES";

			let testPuzzleDefinition = {
				size: 15,
				cells: Array.from(testPuzzleCellContent),
				clues: {
					across: [],
					down: []
				}
			};
			
			function updateCurrentClue(puzzleDefinition, puzzleState) {
				let pd = puzzleDefinition;
				let ps = puzzleState;
				let clearCells = document.querySelectorAll("[class~='puzzle-cell-current-clue']");
				let highlightCells = [];
				if (ps.currentCellEl !== undefined && ps.currentCellEl !== null) {
					let cellindex = parseInt(ps.currentCellEl.getAttribute("cellindex"));
					let i
					let cellEl;
					
					if (ps.direction === "a") {
						let rowStartIndex = cellindex - Math.floor(cellindex % pd.size);
						for (i = cellindex; i >= rowStartIndex; i--) {
							if (pd.cells[i] === "#") {
								break;
							}
							cellEl = document.querySelector(`[cellindex="${i}"]`);
							if (cellEl !== undefined && cellEl !== null) {
								highlightCells.push(cellEl);
							}
						}
						let rowEndIndex = rowStartIndex + pd.size;
						for (i = cellindex + 1; i < rowEndIndex; i++) {
							if (pd.cells[i] === "#") {
								break;
							}
							cellEl = document.querySelector(`[cellindex="${i}"]`);
							if (cellEl !== undefined && cellEl !== null) {
								highlightCells.push(cellEl);
							}
						}
					} else {
						let colStartIndex = Math.floor(cellindex % pd.size);
						for (i = cellindex; i >= colStartIndex; i = i - pd.size) {
							if (pd.cells[i] === "#") {
								break;
							}
							cellEl = document.querySelector(`[cellindex="${i}"]`);
							if (cellEl !== undefined && cellEl !== null) {
								highlightCells.push(cellEl);
							}
						}
						let colEndIndex = ((pd.size * pd.size) - pd.size) + colStartIndex + 1;
						for (i = cellindex + pd.size; i < colEndIndex; i = i + pd.size) {
							if (pd.cells[i] === "#") {
								break;
							}
							cellEl = document.querySelector(`[cellindex="${i}"]`);
							if (cellEl !== undefined && cellEl !== null) {
								highlightCells.push(cellEl);
							}
						}
					}
				}
				
				if (clearCells !== undefined && clearCells !== null) {
					// If a cell to be hightlighted already is highlighted remove it from
					// the list to
					let cells = Array.from(clearCells);
					let difference = cells.filter(cell => !highlightCells.includes(cell));
					for (const el of difference) {
						el.classList.remove("puzzle-cell-current-clue");
					}
				}
				if (highlightCells.length > 0) {
					for (const el of highlightCells) {
						if (!el.classList.contains("puzzle-cell-current-clue")) {
							el.classList.add("puzzle-cell-current-clue");
						}
					}
				}
			}
			
			let testPuzzleState = {
				direction: "a", // [a]cross or [d]own
				currentCellEl: undefined,
				cellGuesses: [],
				toggleDirection: function toggleDirection() {
					if (this.direction === "a") {
						this.direction = "d";
					} else {
						this.direction = "a";
					}
				}
			}
			
			function createPuzzleGrid(puzzleDefinition) {
				let pd = puzzleDefinition;
				let puzzleHtml = "";

				let cellNumber = 0;
				for (let cellIndex = 0; cellIndex < pd.size * pd.size; cellIndex++) {
					let displayCellNumber = "";
					if (pd.cells[cellIndex] != "#") {
						let row = Math.floor(cellIndex / pd.size);
						let col = Math.floor(cellIndex % pd.size);
						if (row == 0 || col == 0) {
							cellNumber = cellNumber + 1;
							displayCellNumber = "" + cellNumber;
						} else if (cellIndex > 0 && pd.cells[cellIndex -1] == "#" ||
								   cellIndex > pd.size && pd.cells[cellIndex - pd.size] == "#") {
							cellNumber = cellNumber + 1;
							displayCellNumber = "" + cellNumber;
						}
					}
					let moreClass = "";
					let tabIndex = 'tabindex="0"';
					if (pd.cells[cellIndex] === "#") {
						moreClass = "puzzle-cell-block";
						tabIndex = "";
					}
					puzzleHtml += `<div class="puzzle-cell ${moreClass}" ${tabIndex} cellindex="${cellIndex}" cellnumber="${displayCellNumber}"></div>`
				}
				return puzzleHtml;
			}
			
			function displayPuzzle(puzzleDefinition, puzzleHtml) {
				let puzzleEl = document.querySelector("div.puzzle-grid");
				if (puzzleEl !== undefined && puzzleEl !== null) {
					puzzleEl.style.setProperty("--puzzle-size", "" + puzzleDefinition.size);
					puzzleEl.innerHTML = puzzleHtml;
				}
			}
			
		</script>
		
		<style>
		* {
			margin: 0;
			font-family: sans-serif;
			font-size: 12pt;
		}

		@media (min-resolution: 150dpi) {
			* {
				font-size: 2rem;
			}
		}

		html {
			background-color: #325891;
		}
		
		body {
			background-color: #5d5d5d;
			color: #ffffff;
			padding: 0px;
			background-color: #FBFBFB;
			height: calc(100vh - 3.5rem);
			user-select: none;
			overflow: hidden;
			display: flex;
			flex-direction: column;
			align-items: stretch;
			border-style: none;
		}
		
		.puzzle {
			flex: 1 1 auto;
			overflow: hidden;
		}
		
		.puzzle-content {
			display: flex;
			height: 100%;
			flex-direction: column;
		}

		.puzzle-clue {
			background-color: #5d5d5d;
			z-index: 1;
		}
		
		.puzzle-grid {
			flex: 1 1 auto;
			padding: 0;
			overflow: auto;
			display: inline-grid;
			grid-template-columns: repeat(var(--puzzle-size), 1fr);
			grid-column-gap: 1px;
			grid-row-gap: 1px;
			background-color: black;
		}

		.puzzle-cell {
			display: inline-grid;
			font-size: 1.5rem;
			width: 2rem;
			height: 2rem;
			color: black;
			background-color: white;
			padding: .1rem;
			justify-content: center;
			align-content: center;
			user-select: none;
		}

		@media (min-resolution: 150dpi) {
			.puzzle-cell {
				font-size: 2.5rem;
				width: 4rem;
				height: 4rem;
			}
		}
		
		.puzzle-cell-current-clue {
			background-color: #F3B169;
		}
		
		.puzzle-cell-block {
			background-color: black;
		}
		
		.puzzle-cell-focus {
			background-color: #DD6A2A;
		}
		
		.puzzle-cell::before {
			content: attr(cellnumber);
			display: inline-block;
			font-size: .5rem;
			position: absolute;
		}

		@media (min-resolution: 150dpi) {
			.puzzle-cell::before {
				font-size: 1rem;
			}
		}
		
		.puzzle-input {
			opacity: 0;
		}
		
		.puzzle-keyboard {
			flex: 0 0 auto;
			border-top-style: solid;
			border-top-width: 1px;
			border-top-color: lightgray;
			padding: 0.5rem;
			display: inline-grid;
			grid-template-columns: repeat(10, 1fr);
			font-size: 1.25rem;
			background-color: white;
			color: black;
			cursor: default;
			width: min-content;
		}
		
		.puzzle-keyboard-key {
			display: inline-grid;
			width: 2rem;
			height: 2rem;
			justify-content: center;
			align-content: center;
			user-select: none;
		}

		@media (min-resolution: 150dpi) {
			.puzzle-keyboard-key {
				font-size: 2.5rem;
				width: 4rem;
				height: 4rem;
			}
		}
		
		.puzzle-keyboard-key:hover {
			outline: none;
			box-shadow: inset 0 0 0 0.2rem rgba(38,143,255,.5);
		}
		
		
		</style>
	</head>
	<body>
	<div class="puzzle">
		<div class="puzzle-content">
			<div class="puzzle-clue">This is the crosswords top.</div>
			<div class="puzzle-grid"></div>
		</div>
		<div class="puzzle-keyboard">
			<div class="puzzle-keyboard-key">q</div><div class="puzzle-keyboard-key">w</div><div class="puzzle-keyboard-key">e</div><div class="puzzle-keyboard-key">r</div><div class="puzzle-keyboard-key">t</div><div class="puzzle-keyboard-key">y</div><div class="puzzle-keyboard-key">u</div><div class="puzzle-keyboard-key">i</div><div class="puzzle-keyboard-key">o</div><div class="puzzle-keyboard-key">p</div>
			<div class="puzzle-keyboard-key">a</div><div class="puzzle-keyboard-key">s</div><div class="puzzle-keyboard-key">d</div><div class="puzzle-keyboard-key">f</div><div class="puzzle-keyboard-key">g</div><div class="puzzle-keyboard-key">h</div><div class="puzzle-keyboard-key">j</div><div class="puzzle-keyboard-key">k</div><div class="puzzle-keyboard-key">l</div><div class="puzzle-keyboard-key"></div>
			<div class="puzzle-keyboard-key">_</div><div class="puzzle-keyboard-key">z</div><div class="puzzle-keyboard-key">x</div><div class="puzzle-keyboard-key">c</div><div class="puzzle-keyboard-key">v</div><div class="puzzle-keyboard-key">b</div><div class="puzzle-keyboard-key">n</div><div class="puzzle-keyboard-key">m</div><div class="puzzle-keyboard-key">bs</div><div class="puzzle-keyboard-key"></div>
		</div>
	</div>
	</body>
</html>